<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python Learning Notes</title>
      <link href="/2024/03/04/python-learning-notes/"/>
      <url>/2024/03/04/python-learning-notes/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">print(&quot;IPO程序编写，input，process，output&quot;)print(&quot;可以使用多种引号，后面不用加分号，可以类似cout一样多重输出&quot;)print(chr(54))print(&quot;python3以Unicode为内部字符编码，一共2的16次方位数&quot;)fp &#x3D; open(&#39;note.txt&#39;, &#39;w&#39;)print(&quot;一个尝试&quot;, file&#x3D;fp)fp.close()print(&quot;nih&quot;, sep&#x3D;&quot;&quot;, end&#x3D;&quot;xcc&quot;)print(&quot;ddd&quot;+&quot;链接符的使用只能是字符串之间&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 毕设学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32 Learning Notes</title>
      <link href="/2024/02/28/stm32-learning-notes/"/>
      <url>/2024/02/28/stm32-learning-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="1-配置文件介绍"><a href="#1-配置文件介绍" class="headerlink" title="1 配置文件介绍"></a>1 配置文件介绍</h2><p><a href="https://www.bilibili.com/opus/814075999736037492?spm_id_from=333.999.0.0">STM32入门教程-2023版 细致讲解 中文字幕 - 哔哩哔哩 (bilibili.com)</a></p><h3 id="1-1-start"><a href="#1-1-start" class="headerlink" title="1.1 start"></a>1.1 start</h3><p><code>\STM32入门教程资料\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">startup_stm32f10x_md.s   <span class="token comment">#启动文件</span>system_stm32f10x.c <span class="token comment">#配置时钟</span>system_stm32f10x.hstm32f10x.h <span class="token comment">#外设寄存器文件，类似reg52.h，描述寄存器与地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>\STM32入门教程资料\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\CoreSupport</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">core_cm3.c <span class="token comment">#内核寄存器描述</span>core_cm3.h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-2-library-标准外设驱动库函数"><a href="#1-2-library-标准外设驱动库函数" class="headerlink" title="1.2 library 标准外设驱动库函数"></a>1.2 library 标准外设驱动库函数</h3><p><code>\STM32入门教程资料\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver</code></p><p>src和inc文件里面的所有文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mics.c  <span class="token comment">#内核的库函数，其他是内核外的库函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-3-user"><a href="#1-3-user" class="headerlink" title="1.3 user"></a>1.3 user</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stm32f10x_conf.h    <span class="token comment">#配置库函数头文件包含关系，检查函数定义</span>stm32f10x_it.c放中断函数stm32f10x_it.h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-4-复制字符串、包含外设库"><a href="#1-4-复制字符串、包含外设库" class="headerlink" title="1.4 复制字符串、包含外设库"></a>1.4 复制字符串、包含外设库</h3><p><img src="https://i1.hdslb.com/bfs/note/10928388fe2ccd500b9ac4383da035fb09f78b94.png@1054w_772h.webp" alt="img"></p><p><img src="https://i1.hdslb.com/bfs/note/17cd28850cab71630152b509b117be6a7f145d67.png@1066w_780h.webp" alt="img"></p><p><img src="https://i1.hdslb.com/bfs/note/942541aa157abb163ebfb5449a729b553c47725e.png@1140w_748h.webp" alt="img"></p><h2 id="2-外设学习"><a href="#2-外设学习" class="headerlink" title="2 外设学习"></a>2 外设学习</h2><h3 id="2-1-GPIO"><a href="#2-1-GPIO" class="headerlink" title="2.1 GPIO"></a>2.1 GPIO</h3><p>io口不初始化，默认浮空输入</p><table><thead><tr><th align="left">八种模式</th><th align="center"><strong>模式名称</strong></th><th align="center"><strong>性质</strong></th><th align="center"><strong>特征</strong></th></tr></thead><tbody><tr><td align="left">GPIO_Mode_IN_FLOATING</td><td align="center">浮空输入</td><td align="center">数字输入</td><td align="center">可读取引脚电平，若引脚悬空，则电平不确定</td></tr><tr><td align="left">GPIO_Mode_IPU</td><td align="center">上拉输入</td><td align="center">数字输入</td><td align="center">可读取引脚电平，内部连接上拉电阻，悬空时默认高电平</td></tr><tr><td align="left">GPIO_Mode_IPD</td><td align="center">下拉输入</td><td align="center">数字输入</td><td align="center">可读取引脚电平，内部连接下拉电阻，悬空时默认低电平</td></tr><tr><td align="left">GPIO_Mode_AIN</td><td align="center">模拟输入</td><td align="center">模拟输入</td><td align="center">GPIO无效，引脚直接接入内部ADC</td></tr><tr><td align="left">GPIO_Mode_Out_OD</td><td align="center">开漏输出</td><td align="center">数字输出</td><td align="center">可输出引脚电平，高电平为高阻态，低电平接VSS</td></tr><tr><td align="left">GPIO_Mode_Out_PP</td><td align="center">推挽输出</td><td align="center">数字输出</td><td align="center">可输出引脚电平，高电平接VDD，低电平接VSS</td></tr><tr><td align="left">GPIO_Mode_AF_OD</td><td align="center">复用开漏输出</td><td align="center">数字输出</td><td align="center">由片上外设控制，高电平为高阻态，低电平接VSS</td></tr><tr><td align="left">GPIO_Mode_AF_PP</td><td align="center">复用推挽输出</td><td align="center">数字输出</td><td align="center">由片上外设控制，高电平接VDD，低电平接VSS</td></tr></tbody></table><h4 id="2-1-1-输出"><a href="#2-1-1-输出" class="headerlink" title="2.1.1 输出"></a>2.1.1 输出</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*开启时钟*/</span><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开启GPIOA的时钟</span><span class="token comment">//使用各个外设前必须开启时钟，否则对外设的操作无效</span><span class="token comment">/*GPIO初始化*/</span>GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span><span class="token comment">//定义结构体变量</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span><span class="token comment">//GPIO模式，赋值为推挽输出模式</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_0<span class="token punctuation">;</span><span class="token comment">//GPIO引脚，赋值为第0号引脚</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span><span class="token comment">//GPIO速度，赋值为50MHz</span><span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将赋值后的构体变量传递给GPIO_Init函数</span><span class="token comment">//函数内部会自动根据结构体的参数配置相应寄存器</span><span class="token comment">//实现GPIOA的初始化</span><span class="token comment">/*方法1：GPIO_ResetBits设置低电平，GPIO_SetBits设置高电平*/</span><span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token operator">|</span>GPIO_Pin_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将PA0,PA1引脚设置为低电平,可“与”计算</span><span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将PA0引脚设置为高电平</span><span class="token comment">/*方法2：GPIO_WriteBit设置低/高电平，由Bit_RESET/Bit_SET指定*/</span><span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">,</span> Bit_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将PA0引脚设置为低电平</span><span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">,</span> Bit_SET<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将PA0引脚设置为高电平</span><span class="token comment">/*方法3：GPIO_WriteBit设置低/高电平，由数据0/1指定，数据需要强转为BitAction类型*/</span><span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">,</span> <span class="token punctuation">(</span>BitAction<span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将PA0引脚设置为低电平</span><span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">,</span> <span class="token punctuation">(</span>BitAction<span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将PA0引脚设置为高电平</span><span class="token comment">/*使用GPIO_Write，同时设置GPIOA所有引脚的高低电平，实现LED流水灯*/</span><span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0001</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//0000 0000 0000 0001，PA0引脚为低电平，其他引脚均为高电平，注意数据有按位取反</span><span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//延时100ms</span><span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0002</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//0000 0000 0000 0010，PA1引脚为低电平，其他引脚均为高电平</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-1-输入"><a href="#2-1-1-输入" class="headerlink" title="2.1.1 输入"></a>2.1.1 输入</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*开启时钟*/</span><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOB<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开启GPIOB的时钟</span><span class="token comment">/*GPIO初始化*/</span>GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IPU<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_1 <span class="token operator">|</span> GPIO_Pin_11<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span><span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将PB1和PB11引脚初始化为上拉输入</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//读PB1输入寄存器的状态，如果为0，则代表按键1按下</span><span class="token punctuation">&#123;</span>    <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//延时消抖</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待按键松手</span>    <span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//延时消抖</span>    KeyNum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//置键码为1</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="OLED调试"><a href="#OLED调试" class="headerlink" title="OLED调试"></a>OLED调试</h3><p>暂无</p><p>•68个可屏蔽中断通道，包含EXTI、TIM、ADC、USART、SPI、I2C、RTC等多个外设</p><h3 id="2-2-EXIT"><a href="#2-2-EXIT" class="headerlink" title="2.2 EXIT"></a>2.2 EXIT</h3><p>•NVIC的中断优先级由优先级寄存器的4位（0~15）决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级</p><p>•抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断号排队</p><table><thead><tr><th><strong>分组方式</strong></th><th><strong>抢占优先级</strong></th><th><strong>响应优先级</strong></th></tr></thead><tbody><tr><td>分组0</td><td>0位，取值为0</td><td>4位，取值为0~15</td></tr><tr><td>分组1</td><td>1位，取值为0~1</td><td>3位，取值为0~7</td></tr><tr><td>分组2</td><td>2位，取值为0~3</td><td>2位，取值为0~3</td></tr><tr><td>分组3</td><td>3位，取值为0~7</td><td>1位，取值为0~1</td></tr><tr><td>分组4</td><td>4位，取值为0~15</td><td>0位，取值为0</td></tr></tbody></table><p>主要函数介绍</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">EXTI_DeInit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用于将外部中断模块恢复到初始状态。</span><span class="token keyword">void</span> <span class="token function">EXTI_Init</span><span class="token punctuation">(</span>EXTI_InitTypeDef<span class="token operator">*</span> EXTI_InitStruct<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用给定的配置初始化外部中断。</span><span class="token keyword">void</span> <span class="token function">EXTI_StructInit</span><span class="token punctuation">(</span>EXTI_InitTypeDef<span class="token operator">*</span> EXTI_InitStruct<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化指定的外部中断配置结构体。</span><span class="token keyword">void</span> <span class="token function">EXTI_GenerateSWInterrupt</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> EXTI_Line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//产生软件触发的外部中断。</span><span class="token comment">//在主函数内查看，触发了标志位不一定会挂起中断，这是区别</span>FlagStatus <span class="token function">EXTI_GetFlagStatus</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> EXTI_Line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*功能：获取指定外部中断线的触发标志位状态。      返回值：标志位状态，可以是SET或者RESET。*/</span><span class="token keyword">void</span> <span class="token function">EXTI_ClearFlag</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> EXTI_Line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//清除指定外部中断线的触发标志位。</span><span class="token comment">//在中断函数内查看，此时可以查看是否已经开启了中断</span>ITStatus <span class="token function">EXTI_GetITStatus</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> EXTI_Line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*功能：获取指定外部中断线的中断挂起状态。  返回值：中断挂起状态，可以是SET或者RESET。*/</span><span class="token keyword">void</span> <span class="token function">EXTI_ClearITPendingBit</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> EXTI_Line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//清除指定外部中断线的中断挂起位。  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*开启时钟*/</span><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_AFIO<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开启AFIO的时钟，外部中断必须开启AFIO的时钟</span><span class="token comment">/*AFIO选择中断引脚*/</span><span class="token function">GPIO_EXTILineConfig</span><span class="token punctuation">(</span>GPIO_PortSourceGPIOB<span class="token punctuation">,</span> GPIO_PinSource14<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将外部中断的14号线映射到GPIOB，即选择PB14为外部中断引脚</span><span class="token comment">/*EXTI初始化*/</span>EXTI_InitTypeDef EXTI_InitStructure<span class="token punctuation">;</span><span class="token comment">//定义结构体变量</span>EXTI_InitStructure<span class="token punctuation">.</span>EXTI_Line <span class="token operator">=</span> EXTI_Line14<span class="token punctuation">;</span><span class="token comment">//选择配置外部中断的14号线</span>EXTI_InitStructure<span class="token punctuation">.</span>EXTI_LineCmd <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span><span class="token comment">//指定外部中断线使能</span>EXTI_InitStructure<span class="token punctuation">.</span>EXTI_Mode <span class="token operator">=</span> EXTI_Mode_Interrupt<span class="token punctuation">;</span><span class="token comment">//指定外部中断线为中断模式</span>EXTI_InitStructure<span class="token punctuation">.</span>EXTI_Trigger <span class="token operator">=</span> EXTI_Trigger_Falling<span class="token punctuation">;</span><span class="token comment">//指定外部中断线为下降沿触发</span><span class="token function">EXTI_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>EXTI_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将结构体变量交给EXTI_Init，配置EXTI外设</span><span class="token comment">/*NVIC中断分组*/</span><span class="token function">NVIC_PriorityGroupConfig</span><span class="token punctuation">(</span>NVIC_PriorityGroup_2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//配置NVIC为分组2</span><span class="token comment">//即抢占优先级范围：0~3，响应优先级范围：0~3</span><span class="token comment">//此分组配置在整个工程中仅需调用一次</span><span class="token comment">//若有多个中断，可以把此代码放在main函数内，while循环之前</span><span class="token comment">//若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置</span><span class="token comment">/*NVIC配置*/</span>NVIC_InitTypeDef NVIC_InitStructure<span class="token punctuation">;</span><span class="token comment">//定义结构体变量</span>NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannel <span class="token operator">=</span> EXTI15_10_IRQn<span class="token punctuation">;</span><span class="token comment">//选择配置NVIC的EXTI15_10线</span>NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelCmd <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span><span class="token comment">//指定NVIC线路使能</span>NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelPreemptionPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//指定NVIC线路的抢占优先级为1</span>NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelSubPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//指定NVIC线路的响应优先级为1</span><span class="token function">NVIC_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>NVIC_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将结构体变量交给NVIC_Init，配置NVIC外设</span><span class="token keyword">void</span> <span class="token function">EXTI15_10_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">EXTI_GetITStatus</span><span class="token punctuation">(</span>EXTI_Line14<span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span><span class="token comment">//判断是否是外部中断14号线触发的中断</span><span class="token punctuation">&#123;</span><span class="token comment">/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_14<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>CountSensor_Count <span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//计数值自增一次</span><span class="token punctuation">&#125;</span><span class="token function">EXTI_ClearITPendingBit</span><span class="token punctuation">(</span>EXTI_Line14<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//清除外部中断14号线的中断标志位</span><span class="token comment">//中断标志位必须清除</span><span class="token comment">//否则中断将连续不断地触发，导致主程序卡死</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-TIM"><a href="#2-3-TIM" class="headerlink" title="2.3 TIM"></a>2.3 TIM</h3><p>预分频器的工作的工作原理是，定时器时钟源每tick一次，<strong>预分频器计数器</strong>值+1，直到达到预分频器的设定值，然后再tick一次后计数器归零，同时，<strong>CNT计数器</strong>值+1。</p><p>由此可以看出，因为达到最大值后还要再tick一次才归零，所以定时器时钟频率应该为Fosc&#x2F;(PSC+ 1)。其中Fosc是定时器的时钟源。比如想对时钟源进行72分频，那么预分频器的值就应该设置为71。</p><p>由此可以看出，因为达到最大值后还要再tick一次才归零，所以定时器时钟频率应该为Fosc&#x2F;(PSC+ 1)。其中Fosc是定时器的时钟源。比如想对时钟源进行72分频，那么预分频器的值就应该设置为71。</p><p>预分频器值寄存器TIMx_PSC存在影子寄存器（官方翻译为缓冲功能），所以在定时器启动后更改TIMx_PSC的值并不会立即影响当前定时器的时钟频率。要等到下一个更新事件（UEV）发生时才会生效。比如下边这张图就体现了将分频系数由1修改为2（即TIMx_PSC由0更改为1）时整个定时器的时序图。</p><p><img src="C:\Users\Answerfour\AppData\Roaming\Typora\typora-user-images\image-20240324104734248.png" alt="image-20240324104734248"></p><p>更新事件（UEV）则由TIMx_CR1寄存器中的UDIS位控制，在启用时，会通过以下两种方式触发 ：</p><ul><li>计数器上溢</li><li>手动将 TIMx_EGR 寄存器中的UG 位置 1</li></ul><p><a href="https://zhuanlan.zhihu.com/p/82590576">STM32定时器（TIM）之预分频器（PSC）详解 - 知乎 (zhihu.com)</a></p><h4 id="2-3-1-定时中断"><a href="#2-3-1-定时中断" class="headerlink" title="2.3.1 定时中断"></a>2.3.1 定时中断</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*开启时钟*/</span><span class="token function">RCC_APB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB1Periph_TIM2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开启TIM2的时钟</span><span class="token comment">/*配置时钟源*/</span><span class="token function">TIM_InternalClockConfig</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//选择TIM2为内部时钟，若不调用此函数，TIM默认也为内部时钟</span><span class="token comment">/*时基单元初始化*/</span>TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure<span class="token punctuation">;</span><span class="token comment">//定义结构体变量</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_ClockDivision <span class="token operator">=</span> TIM_CKD_DIV1<span class="token punctuation">;</span><span class="token comment">//时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_CounterMode <span class="token operator">=</span> TIM_CounterMode_Up<span class="token punctuation">;</span><span class="token comment">//计数器模式，选择向上计数</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Period <span class="token operator">=</span> <span class="token number">10000</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//计数周期，即ARR的值</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Prescaler <span class="token operator">=</span> <span class="token number">7200</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//预分频器，即PSC的值</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_RepetitionCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//重复计数器，高级定时器才会用到</span><span class="token function">TIM_TimeBaseInit</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_TimeBaseInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元</span><span class="token comment">/*中断输出配置*/</span><span class="token function">TIM_ClearFlag</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> TIM_FLAG_Update<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//清除定时器更新标志位</span>                                                            <span class="token comment">//TIM_TimeBaseInit函数末尾，手动产生了更新事件</span>                                                            <span class="token comment">//若不清除此标志位，则开启中断后，会立刻进入一次中断</span>                                                            <span class="token comment">//如果不介意此问题，则不清除此标志位也可</span><span class="token function">TIM_ITConfig</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> TIM_IT_Update<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开启TIM2的更新中断</span><span class="token comment">/*NVIC中断分组*/</span><span class="token function">NVIC_PriorityGroupConfig</span><span class="token punctuation">(</span>NVIC_PriorityGroup_2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//配置NVIC为分组2</span>                                               <span class="token comment">//即抢占优先级范围：0~3，响应优先级范围：0~3</span>                                               <span class="token comment">//此分组配置在整个工程中仅需调用一次</span>                                               <span class="token comment">//若有多个中断，可以把此代码放在main函数内，while循环之前</span>                                               <span class="token comment">//若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置</span><span class="token comment">/*NVIC配置*/</span>NVIC_InitTypeDef NVIC_InitStructure<span class="token punctuation">;</span><span class="token comment">//定义结构体变量</span>NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannel <span class="token operator">=</span> TIM2_IRQn<span class="token punctuation">;</span><span class="token comment">//选择配置NVIC的TIM2线</span>NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelCmd <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span><span class="token comment">//指定NVIC线路使能</span>NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelPreemptionPriority <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//指定NVIC线路的抢占优先级为2</span>NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelSubPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//指定NVIC线路的响应优先级为1</span><span class="token function">NVIC_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>NVIC_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将结构体变量交给NVIC_Init，配置NVIC外设</span><span class="token comment">/*TIM使能*/</span><span class="token function">TIM_Cmd</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使能TIM2，定时器开始运行</span><span class="token comment">/*定时器中断函数，可以复制到使用它的地方void TIM2_IRQHandler(void)&#123;if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)&#123;        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);&#125;*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-2-外部时钟中断"><a href="#2-3-2-外部时钟中断" class="headerlink" title="2.3.2 外部时钟中断"></a>2.3.2 外部时钟中断</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*外部时钟配置*/</span><span class="token function">TIM_ETRClockMode2Config</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> TIM_ExtTRGPSC_OFF<span class="token punctuation">,</span> TIM_ExtTRGPolarity_NonInverted<span class="token punctuation">,</span> <span class="token number">0x0F</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//选择外部时钟模式2，时钟从TIM_ETR引脚输入</span><span class="token comment">//注意TIM2的ETR引脚固定为PA0，无法随意更改</span><span class="token comment">//最后一个滤波器参数加到最大0x0F，可滤除时钟信号抖动</span><span class="token comment">/*时基单元初始化*/</span>TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure<span class="token punctuation">;</span><span class="token comment">//定义结构体变量</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_ClockDivision <span class="token operator">=</span> TIM_CKD_DIV1<span class="token punctuation">;</span><span class="token comment">//时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_CounterMode <span class="token operator">=</span> TIM_CounterMode_Up<span class="token punctuation">;</span><span class="token comment">//计数器模式，选择向上计数</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Period <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//计数周期，即ARR的值</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Prescaler <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//预分频器，即PSC的值</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_RepetitionCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//重复计数器，高级定时器才会用到</span><span class="token function">TIM_TimeBaseInit</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_TimeBaseInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-3-时钟输出比较"><a href="#2-3-3-时钟输出比较" class="headerlink" title="2.3.3 时钟输出比较"></a>2.3.3 时钟输出比较</h4><p>•PWM频率： Freq &#x3D; CK_PSC &#x2F; (PSC + 1) &#x2F; (ARR + 1)</p><p>•PWM占空比： Duty &#x3D; CCR &#x2F; (ARR + 1)</p><p>•PWM分辨率： Reso &#x3D; 1 &#x2F; (ARR + 1)</p><p><img src="C:\Users\Answerfour\AppData\Roaming\Typora\typora-user-images\image-20240324091032111.png" alt="image-20240324091032111"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*开启时钟*/</span><span class="token function">RCC_APB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB1Periph_TIM2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开启TIM2的时钟</span><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开启GPIOA的时钟</span><span class="token comment">/*GPIO重映射*/</span><span class="token comment">//RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);//开启AFIO的时钟，重映射必须先开启AFIO的时钟</span><span class="token comment">//GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE);//将TIM2的引脚部分重映射，具体的映射方案需查看参考手册</span><span class="token comment">//GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);//将JTAG引脚失能，作为普通GPIO引脚使用</span><span class="token comment">/*GPIO初始化*/</span>GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_AF_PP<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_0<span class="token punctuation">;</span><span class="token comment">//GPIO_Pin_15;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span><span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将PA0引脚初始化为复用推挽输出</span>                                                                <span class="token comment">//受外设控制的引脚，均需要配置为复用模式</span><span class="token comment">/*配置时钟源*/</span><span class="token function">TIM_InternalClockConfig</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//选择TIM2为内部时钟，若不调用此函数，TIM默认也为内部时钟</span><span class="token comment">/*时基单元初始化*/</span>TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure<span class="token punctuation">;</span><span class="token comment">//定义结构体变量</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_ClockDivision <span class="token operator">=</span> TIM_CKD_DIV1<span class="token punctuation">;</span>     <span class="token comment">//时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_CounterMode <span class="token operator">=</span> TIM_CounterMode_Up<span class="token punctuation">;</span> <span class="token comment">//计数器模式，选择向上计数</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Period <span class="token operator">=</span> <span class="token number">100</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//计数周期，即ARR的值</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Prescaler <span class="token operator">=</span> <span class="token number">720</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//预分频器，即PSC的值</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_RepetitionCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment">//重复计数器，高级定时器才会用到</span><span class="token function">TIM_TimeBaseInit</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_TimeBaseInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">//将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元</span><span class="token comment">/*输出比较初始化*/</span>TIM_OCInitTypeDef TIM_OCInitStructure<span class="token punctuation">;</span><span class="token comment">//定义结构体变量</span><span class="token function">TIM_OCStructInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TIM_OCInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结构体初始化，若结构体没有完整赋值</span>                                        <span class="token comment">//则最好执行此函数，给结构体所有成员都赋一个默认值</span>                                        <span class="token comment">//避免结构体初值不确定的问题</span>TIM_OCInitStructure<span class="token punctuation">.</span>TIM_OCMode <span class="token operator">=</span> TIM_OCMode_PWM1<span class="token punctuation">;</span><span class="token comment">//输出比较模式，选择PWM模式1</span>TIM_OCInitStructure<span class="token punctuation">.</span>TIM_OCPolarity <span class="token operator">=</span> TIM_OCPolarity_High<span class="token punctuation">;</span><span class="token comment">//输出极性，选择为高，若选择极性为低，则输出高低电平取反</span>TIM_OCInitStructure<span class="token punctuation">.</span>TIM_OutputState <span class="token operator">=</span> TIM_OutputState_Enable<span class="token punctuation">;</span><span class="token comment">//输出使能</span>TIM_OCInitStructure<span class="token punctuation">.</span>TIM_Pulse <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//初始的CCR值</span><span class="token function">TIM_OC1Init</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_OCInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将结构体变量交给TIM_OC1Init，配置TIM2的输出比较通道1</span><span class="token comment">/*TIM使能*/</span><span class="token function">TIM_Cmd</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使能TIM2，定时器开始运行</span><span class="token punctuation">&#125;</span><span class="token comment">/*** 函    数：PWM设置CCR* 参    数：Compare 要写入的CCR的值，范围：0~100* 返 回 值：无* 注意事项：CCR和ARR共同决定占空比，此函数仅设置CCR的值，并不直接是占空比*           占空比Duty = CCR / (ARR + 1)*/</span><span class="token keyword">void</span> <span class="token function">PWM_SetCompare1</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span> Compare<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">TIM_SetCompare1</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> Compare<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置CCR1的值</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-4-时钟输入捕获"><a href="#2-3-4-时钟输入捕获" class="headerlink" title="2.3.4 时钟输入捕获"></a>2.3.4 时钟输入捕获</h4><p>PWMI接占空比</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*输入捕获初始化*/</span>TIM_ICInitTypeDef TIM_ICInitStructure<span class="token punctuation">;</span><span class="token comment">//定义结构体变量</span>TIM_ICInitStructure<span class="token punctuation">.</span>TIM_Channel <span class="token operator">=</span> TIM_Channel_1<span class="token punctuation">;</span><span class="token comment">//选择配置定时器通道1</span>TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICFilter <span class="token operator">=</span> <span class="token number">0xF</span><span class="token punctuation">;</span><span class="token comment">//输入滤波器参数，可以过滤信号抖动</span>TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICPolarity <span class="token operator">=</span> TIM_ICPolarity_Rising<span class="token punctuation">;</span><span class="token comment">//极性，选择为上升沿触发捕获</span>TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICPrescaler <span class="token operator">=</span> TIM_ICPSC_DIV1<span class="token punctuation">;</span><span class="token comment">//捕获预分频，选择不分频，每次信号都触发捕获</span>TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICSelection <span class="token operator">=</span> TIM_ICSelection_DirectTI<span class="token punctuation">;</span><span class="token comment">//输入信号交叉，选择直通，不交叉</span><span class="token function">TIM_ICInit</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_ICInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道</span><span class="token comment">/*选择触发源及从模式*/</span><span class="token function">TIM_SelectInputTrigger</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> TIM_TS_TI1FP1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//触发源选择TI1FP1</span><span class="token function">TIM_SelectSlaveMode</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> TIM_SlaveMode_Reset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从模式选择复位</span>                                                                <span class="token comment">//即TI1产生上升沿时，会触发CNT归零</span><span class="token function">TIM_PWMIConfig</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_ICInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将结构体变量交给TIM_PWMIConfig，配置TIM3的输入捕获通道</span><span class="token comment">//此函数同时会把另一个通道配置为相反的配置，实现PWMI模式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编码器接口测速</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*输入捕获初始化*/</span>TIM_ICInitTypeDef TIM_ICInitStructure<span class="token punctuation">;</span><span class="token comment">//定义结构体变量</span><span class="token function">TIM_ICStructInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TIM_ICInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结构体初始化，若结构体没有完整赋值</span><span class="token comment">//则最好执行此函数，给结构体所有成员都赋一个默认值</span><span class="token comment">//避免结构体初值不确定的问题</span>TIM_ICInitStructure<span class="token punctuation">.</span>TIM_Channel <span class="token operator">=</span> TIM_Channel_1<span class="token punctuation">;</span><span class="token comment">//选择配置定时器通道1</span>TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICFilter <span class="token operator">=</span> <span class="token number">0xF</span><span class="token punctuation">;</span><span class="token comment">//输入滤波器参数，可以过滤信号抖动</span><span class="token function">TIM_ICInit</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_ICInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道</span>TIM_ICInitStructure<span class="token punctuation">.</span>TIM_Channel <span class="token operator">=</span> TIM_Channel_2<span class="token punctuation">;</span><span class="token comment">//选择配置定时器通道2</span>TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICFilter <span class="token operator">=</span> <span class="token number">0xF</span><span class="token punctuation">;</span><span class="token comment">//输入滤波器参数，可以过滤信号抖动</span><span class="token function">TIM_ICInit</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_ICInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道</span><span class="token comment">/*编码器接口配置*/</span><span class="token function">TIM_EncoderInterfaceConfig</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> TIM_EncoderMode_TI12<span class="token punctuation">,</span> TIM_ICPolarity_Rising<span class="token punctuation">,</span> TIM_ICPolarity_Rising<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//配置编码器模式以及两个输入通道是否反相</span><span class="token comment">//注意此时参数的Rising和Falling已经不代表上升沿和下降沿了，而是代表是否反相</span><span class="token comment">//此函数必须在输入捕获初始化之后进行，否则输入捕获的配置会覆盖此函数的部分配置</span><span class="token comment">/*TIM使能*/</span><span class="token function">TIM_Cmd</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使能TIM3，定时器开始运行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-ADC"><a href="#2-3-ADC" class="headerlink" title="2.3 ADC"></a>2.3 ADC</h3><p>STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道</p><h3 id="2-4-DMA"><a href="#2-4-DMA" class="headerlink" title="2.4 DMA"></a>2.4 DMA</h3><h3 id="2-5-USART"><a href="#2-5-USART" class="headerlink" title="2.5 USART"></a>2.5 USART</h3><h3 id="2-6-I2C"><a href="#2-6-I2C" class="headerlink" title="2.6 I2C"></a>2.6 I2C</h3><h3 id="2-7-SPI"><a href="#2-7-SPI" class="headerlink" title="2.7 SPI"></a>2.7 SPI</h3>]]></content>
      
      
      <categories>
          
          <category> 毕设学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>叠加态</title>
      <link href="/2024/02/27/2024-02-27-NULL/"/>
      <url>/2024/02/27/2024-02-27-NULL/</url>
      
        <content type="html"><![CDATA[<p>我时常陷入一种叠加态，故事里的我有时疯狂癫狂热烈盈眶，有时寂静如冬像是一片无声无息的雪花般落入雪地。</p><p>有时我想为什么要记录，为什么要记录生活，有时我希望向他人分享自己的生活，我想让我的朋友知道我过的不错，过的很好，假如我们有机会再次相见的话，让我们回忆往昔一起聊聊最近的事情吧。你可以去西藏去新疆，甚至哈萨克斯坦都行，我说我最近工作有点累，老板让我一直加班一直没休息，虽然我辞不了辞职无法像你一样到处天南地北地享受这个世界，但是我真的很开心再次见到你看到你过的这么好我心底也很开心你问我为什么因为你是我朋友</p><p>至少我认为你是我朋友。人这一辈子无非是循环往复地重复一年又一年的事情。有些人工作了一年又一年或者换了一份又一份的工作，但其实他们从未长大，人生就好比你玩游戏打怪升级，你20级的时候刷着20级的怪，那时你觉得眼前的怪兽怒火滔天，你费劲千辛万苦好不容易打败它之后，带着伤口与装备前往下一个旅途，多年后你40级了，面对眼前40级的怪兽你发现它仍然怒火滔天，气势汹汹，这只生活的怪兽逼得你喘不过气来，但你最后还是坚持了下去。你发现这一幕好像有点眼熟，你回到20级的光卡，发现曾经的怪兽动作是那么地缓慢，你以为它怒火滔天气势汹汹，结果你一看原来它的火苗是那么渺小，你身穿坚铠，小小火苗哪里烫得到你。</p><p>你开始怀疑自己怎么当时的自己那么傻，这么简单的光卡也要费尽心思那么久才能过关。你想着说假如是现在的你肯定能一招ko它，甚至还以为来一步华丽的连招，说不定还可以尝试一下无伤速通。</p><p>可你突然醒过来了，不是这样的，20有20及的困难，40有40及的要求，如果那个时候没打赢boss你也得通光，每次都只有一次机会，20ji的你也曾幻想过未来的你有多模优秀，但是这和现在无光，每个人面对的都是现在的光卡，大多数人没有外挂，无法氪金，对于现在那个等级的你对应的那个怪兽来说，眼前的boss，就是如此地怒火滔天气势汹汹，它每一次吐息都能烧死你。</p><p>不要埋怨过去的自己，她当时面对着眼前的困难没有逃避，已经和你现在一样勇敢和强大 了。</p><p>每一关对于现在的自己来说，都是最终决战。</p><p>旅途的过程我们都会遇到许多朋友，有些你们彼此互相认为对方是朋友，有些只是当方面的朋友。</p><p>可对我来说这并没有什么，我的朋友很少，在我看来朋友如兄弟，旧时的江湖讲究同年同月同日死，少年时妹妹读到这些慷慨ji’an的文字，心中便浑然升起一股热血，现在想来看来我当时就注定是这种人了，我向往着那种侠义精神，向往着有一些可以让自己为此付出一切的朋友。对啊，这才是朋友，哪怕我一无所有，看到你过得不错，我也觉得我的生活突然没那么赖了，每个人都需要有些可以让自己为之付出的东西，我觉得着一点都不赖，我喜欢这钟感觉。我可以和每个人说我们是好朋友，但其实只有我自己新的知道，朋友是一种很珍贵的东西，不是谁都可以当我的朋友付出一切的。</p><p>尽管有时候他们不会这么觉得。时间会冲刷掉大量的东西，当你们重聚彼此回忆往昔，你以为你们还能像往常一样无话不谈，可他甚至会忘了你说的每一个词语。那个他，那个她，还有你们一起认识的哪些他们，你以为你们都不会忘记彼此，可没想到只有你一个人留在过去，抱着往昔苟延残喘。</p><p>你不知道该说什么了，只能报以沉默与倾听。问问他最近过的怎么样。庆幸他还记得你，记得你的名字，记得那为数不多的你们共同经历的一切。</p><p>那时我以为每一部小说都该有结局。我不知道什么叫断更，就像小说作者突然间用一些莫名其妙的理由结束章节，留下小说里的主人公永远停留在在那个割裂的世界，周而复始，以为只要不再翻开最后一页，再次打开的时候就能继续回到以前。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS Learning Notes</title>
      <link href="/2024/02/20/ros-learning-notes/"/>
      <url>/2024/02/20/ros-learning-notes/</url>
      
        <content type="html"><![CDATA[<p>测试带宽</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rostopic rw /image_raw<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">roslaunch robot_vision ar_track.launch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-2-4-OpenCV-边缘检测类"><a href="#4-2-4-OpenCV-边缘检测类" class="headerlink" title="4.2.4 OpenCV-边缘检测类"></a>4.2.4 OpenCV-边缘检测类</h4><p><strong>4.2.4.1 边缘检测</strong></p><p><strong>机器人端</strong>启动摄像头roslaunch robot_vision robot_camera.launch</p><p><strong>机器人端</strong>启动边缘检测roslaunch robot_vision edge_detection.launch</p><p><strong>PC端</strong>用两个终端打开两个rqt_image_view工具，分别订阅&#x2F;image_raw&#x2F;compressed和&#x2F;edge_detection&#x2F;image&#x2F;compressed</p><p>边缘检测可以提取图像中明暗或者颜色变化较大的图像边缘。</p><p>边缘检测可以传送参数进去，默认情况是0，可修改传进去的参数</p><p>roslaunch robot_vision edge_detection.launch edge_type:&#x3D;2</p><p>可以看到纸箱已经完全看不清了，而另一个箱子金属边框和黑色箱体颜色明暗对比非常强烈的就被抽象成了一些线条。通过边缘检测将复杂的图像抽象成一些线条以后，就可以从中提取特征。</p><p><strong>4.2.4.2</strong> <strong>霍夫直线检测</strong></p><p>机器人端启动摄像头roslaunch robot_vision robot_camera.launch</p><p>机器人端启动直线检测roslaunch robot_vision hough_lines.launch</p><p>PC端两个rqt_image_view工具分别订阅&#x2F;image_raw&#x2F;compressed和&#x2F;hough_lines&#x2F;image&#x2F;compressed</p><p>**4.2.4.2 ** <strong>霍夫圆检测</strong></p><p>机器人端启动摄像头roslaunch robot_vision robot_camera.launch</p><p>机器人端启动圆形检测roslaunch robot_vision hough_circles.launch</p><p>PC端两个rqt_image_view工具分别订阅&#x2F;image_raw&#x2F;compressed和&#x2F;hough_circles&#x2F;image&#x2F;compressed</p><h4 id="4-2-5-OpenCV-结构分析类"><a href="#4-2-5-OpenCV-结构分析类" class="headerlink" title="4.2.5 OpenCV-结构分析类"></a>4.2.5 OpenCV-结构分析类</h4><h5 id="4-2-5-1-find-contours轮廓检测"><a href="#4-2-5-1-find-contours轮廓检测" class="headerlink" title="4.2.5.1 find_contours轮廓检测"></a>4.2.5.1 find_contours轮廓检测</h5><p><strong>机器人端</strong>启动摄像头roslaunch robot_vision robot_camera.launch</p><p><strong>机器人端</strong>启动轮廓检测roslaunch robot_vision find_contours.launch</p><p><strong>PC****端</strong>两个rqt_image_view工具分别订阅&#x2F;image_raw&#x2F;compressed和&#x2F;find_contours&#x2F;image&#x2F;compressed</p><p>可以看到轮廓检测是将整个手掌的轮廓都描绘出来了，它和前面介绍的边缘检测是有区别的。边缘检测是将边缘的线条描绘出来，而轮廓检测是将整个轮廓显示出来了。</p><p>这里我们重新打开一个动态调参工具rosrun rqt_reconfigure rqt_reconfigure</p><p>选择find_contours在右侧可以动态调节参数来改变图像效果</p><h5 id="4-2-5-2-general-contours轮廓检测"><a href="#4-2-5-2-general-contours轮廓检测" class="headerlink" title="4.2.5.2 general_contours轮廓检测"></a>4.2.5.2 general_contours轮廓检测</h5><p>机器人端启动摄像头roslaunch robot_vision robot_camera.launch</p><p>机器人端启动一个通用的轮廓检测roslaunch robot_vision general_contours.launch</p><p>rqt_image_view工具订阅&#x2F;general_contours&#x2F;image&#x2F;compressed</p><p>这个节点不再描绘具体的轮廓，而是通过矩形将轮廓包围出来。当我们需要对图片进行分析时，需要将图片提取出来。而在上一个例程当中，获取到的具体轮廓是一个不规则图形它是无法提取成一张图片的。而这个节点描绘的方框可以被截取获得一张新的图片。</p><p>我们输出一下矩形描述相关的话题</p><p>rostopic echo &#x2F;general_contours&#x2F;rectangles</p><p>这里会输出矩形的中心和长宽摆放的角度，这样就可以根据这些信息去图像内截取矩形。</p><h5 id="4-2-5-3-凸包检测-convex-hull"><a href="#4-2-5-3-凸包检测-convex-hull" class="headerlink" title="4.2.5.3 凸包检测 convex_hull"></a>4.2.5.3 凸包检测 convex_hull</h5><p><strong>机器人端</strong>启动摄像头roslaunch robot_vision robot_camera.launch</p><p><strong>机器人端</strong>启动凸包检查roslaunch robot_vision convex_hull.launch</p><p>rqt_image_view工具订阅&#x2F;convex_hull&#x2F;image&#x2F;compressed</p><p>凸包就是将最外层的点连接起来构成凸多边形，这种方式介于轮廓检测和通用轮廓检测之间。这个多边形不会存在内凹，这样能用最小的面积围出轮廓所在区域。</p><h5 id="4-2-5-3-图像矩计算-Contour-Moments"><a href="#4-2-5-3-图像矩计算-Contour-Moments" class="headerlink" title="4.2.5.3 图像矩计算 Contour_Moments"></a>4.2.5.3 图像矩计算 Contour_Moments</h5><p><strong>机器人端</strong>启动摄像头roslaunch robot_vision robot_camera.launch</p><p><strong>PC****端</strong>启动图像计算roslaunch robot_vision contour_moments.launch debug_view:&#x3D;true</p><p>图像计算的应用会启动一个图像化的调试窗口（右侧）</p><p><strong>机器人端或PC端</strong>运行rostopic echo&#x2F;contour_moments&#x2F;moments</p><p>这个话题会输出对图像的一些计算包括重心，中心，周长，面积等。</p><h4 id="4-2-6-OpenCV-运动分析类"><a href="#4-2-6-OpenCV-运动分析类" class="headerlink" title="4.2.6 OpenCV-运动分析类"></a>4.2.6 OpenCV-运动分析类</h4><p>本节内容介绍OpenCV中的运动分析类demo</p><h5 id="4-2-6-1-goodfeature-track-角点检测"><a href="#4-2-6-1-goodfeature-track-角点检测" class="headerlink" title="4.2.6.1 goodfeature_track 角点检测"></a>4.2.6.1 goodfeature_track 角点检测</h5><p><strong>机器人端</strong>启动摄像头roslaunch robot_vision robot_camera.launch</p><p><strong>机器人端</strong>启动角点检测roslaunch robot_vision goodfeature_track.launch</p><p><strong>PC****端</strong>启动rqt_image_view工具&#x2F;goodfeature_track&#x2F;image&#x2F;compressed</p><h5 id="4-2-6-2-camshift-物体检测"><a href="#4-2-6-2-camshift-物体检测" class="headerlink" title="4.2.6.2 camshift 物体检测"></a>4.2.6.2 camshift 物体检测</h5><p><strong>机器人端</strong>启动摄像头roslaunch robot_vision robot_camera.launch</p><p><strong>PC****端</strong>启动物体跟踪roslaunch robot_vision camshift.launch debug_view:&#x3D;true</p><p>用一款PCB板做个示范，鼠标左键框选中板子以后，移动板子就可以看到板子是被追踪的。这个就是利用检测到的特征点来实现的持续追踪。</p><h5 id="4-2-6-3-fback-flow-稠密光流"><a href="#4-2-6-3-fback-flow-稠密光流" class="headerlink" title="4.2.6.3 fback_flow 稠密光流"></a>4.2.6.3 fback_flow 稠密光流</h5><p><strong>机器人端</strong>启动摄像头roslaunch robot_vision robot_camera.launch</p><p><strong>机器人端</strong>启动roslaunch robot_vision fback_flow.launch</p><p><strong>PC****端</strong>启动rqt_image_view工具&#x2F;fback_fl<code>ow/image/compressed</code></p><h5 id="4-2-6-4-lk-flow-稀疏光流"><a href="#4-2-6-4-lk-flow-稀疏光流" class="headerlink" title="4.2.6.4 lk_flow 稀疏光流"></a>4.2.6.4 lk_flow 稀疏光流</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">roslaunch robot_vision robot_camera.launchroslaunch robot_vision lk_flow.launch debug_view:<span class="token operator">=</span>true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="4-2-6-5-phase-corr-相位法光流"><a href="#4-2-6-5-phase-corr-相位法光流" class="headerlink" title="4.2.6.5 phase_corr 相位法光流"></a>4.2.6.5 phase_corr 相位法光流</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">roslaunch robot_vision robot_camera.launchroslaunch robot_vision phase_corr.launch debug_view:<span class="token operator">=</span>true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="4-2-6-6简单光流检测："><a href="#4-2-6-6简单光流检测：" class="headerlink" title="4.2.6.6简单光流检测："></a>4.2.6.6简单光流检测：</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">roslaunch robot_vision robot_camera.launchroslaunch robot_vision simple_flow.launch debug_view:<span class="token operator">=</span>true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="4-2-7OpenCV-对象分割类"><a href="#4-2-7OpenCV-对象分割类" class="headerlink" title="4.2.7OpenCV-对象分割类"></a>4.2.7OpenCV-对象分割类</h4><p>本节内容介绍OpenCV中的对象分割类demo的运行</p><h5 id="4-2-7-1物体分割-segment-objects"><a href="#4-2-7-1物体分割-segment-objects" class="headerlink" title="4.2.7.1物体分割 segment_objects"></a>4.2.7.1物体分割 segment_objects</h5><p><strong>机器人端</strong>启动摄像头roslaunch robot_vision robot_camera.launch</p><p><strong>机器人端</strong>启动对象分割roslaunch robot_vision segment_objects.launch</p><p><strong>PC****端</strong>用两个终端打开两个rqt_image_view工具，分别订阅&#x2F;image_raw&#x2F;compressed和&#x2F;segment_objects&#x2F;image&#x2F;compressed</p><p>在右侧的图像原本是全黑的，当PCB板突然出现在摄像头下时。就会在右侧黑色背景下显示出来。</p><h5 id="4-2-7-2分水岭分割-watershed-segmentation"><a href="#4-2-7-2分水岭分割-watershed-segmentation" class="headerlink" title="4.2.7.2分水岭分割 watershed_segmentation"></a>4.2.7.2分水岭分割 watershed_segmentation</h5><p>机器人端启动roslaunch robot_vision robot_camera.launch</p><p>PC端启动roslaunch robot_vision watershed_segmentation.launch debug_view:&#x3D;true</p><p>此时出现的是摄像头获取到的正常图像</p><h4 id="4-2-8-OpenCV-颜色过滤器类"><a href="#4-2-8-OpenCV-颜色过滤器类" class="headerlink" title="4.2.8 OpenCV-颜色过滤器类"></a>4.2.8 OpenCV-颜色过滤器类</h4><p>本节内容介绍OpenCV中的颜色过滤器类demo的运行</p><h5 id="4-2-8-1-rgb色彩空间过滤-rgb-color-filter"><a href="#4-2-8-1-rgb色彩空间过滤-rgb-color-filter" class="headerlink" title="4.2.8.1 rgb色彩空间过滤 rgb_color_filter"></a>4.2.8.1 rgb色彩空间过滤 rgb_color_filter</h5><p><strong>机器人端</strong>启动摄像头roslaunch robot_vision robot_camera.launch</p><p><strong>机器人端</strong>启动RGB颜色过滤器roslaunch robot_vision rgb_color_filter.launch</p><p><strong>PC****端</strong>用两个终端打开两个rqt_image_view工具，分别订阅&#x2F;image_raw&#x2F;compressed和&#x2F;rgb_color_filter&#x2F;image&#x2F;compressed</p><p>一下就分别是过滤后和原图</p><p>这是因为自然界的颜色都是通过红绿蓝三种颜色通过不同的配比参杂出来的例如(红)+(绿)&#x3D;(黄)等等，我们所见到的蓝色并非纯蓝色，如果只留蓝色其他颜色全部关闭就会什么都不显示。也因此衍生了两外两种颜色描述方法，HSV和HLS</p><p>HSV：Hue色相，Saturation饱和度，Value明度</p><p>HLS：Hue色相，Saturation饱和度，Lightness亮度</p><h5 id="4-2-8-2-hsv-色彩空间过滤-hsv-color-filter"><a href="#4-2-8-2-hsv-色彩空间过滤-hsv-color-filter" class="headerlink" title="4.2.8.2 hsv 色彩空间过滤 hsv_color_filter"></a>4.2.8.2 hsv 色彩空间过滤 hsv_color_filter</h5><p><strong>机器人端</strong>启动摄像头roslaunch robot_vision robot_camera.launch</p><p><strong>机器人端</strong>启动HSV颜色过滤器roslaunch robot_vision hsv_color_filter.launch</p><p><strong>PC****端</strong>用两个终端打开两个rqt_image_view工具，分别订阅&#x2F;image_raw&#x2F;compressed和&#x2F;hsv_color_filter&#x2F;image&#x2F;compressed</p><p>这是刚打开图像工具时显示的画面，可以看到除了蓝色以外还有一些其他颜色也被显示出来了。</p><h5 id="4-2-8-3-hls色彩空间过滤-hls-color-filter"><a href="#4-2-8-3-hls色彩空间过滤-hls-color-filter" class="headerlink" title="4.2.8.3 hls色彩空间过滤 hls_color_filter"></a>4.2.8.3 hls色彩空间过滤 hls_color_filter</h5><p><strong>机器人端</strong>启动摄像头roslaunch robot_vision robot_camera.launch</p><p><strong>机器人端</strong>启动HLS颜色过滤器roslaunch robot_vision hls_color_filter.launch</p><p><strong>PC****端</strong>用两个终端打开两个rqt_image_view工具，分别订阅&#x2F;image_raw&#x2F;compressed和&#x2F;hls_color_filter&#x2F;image&#x2F;compressed</p><h4 id="4-2-9-OpenCV-简单图像处理类"><a href="#4-2-9-OpenCV-简单图像处理类" class="headerlink" title="4.2.9 OpenCV-简单图像处理类"></a>4.2.9 OpenCV-简单图像处理类</h4><p>本节内容介绍OpenCV中简单图像处理类的应用</p><h5 id="4-2-9-1-OpenCV中图像格式和ROS话题格式相互转换"><a href="#4-2-9-1-OpenCV中图像格式和ROS话题格式相互转换" class="headerlink" title="4.2.9.1 OpenCV中图像格式和ROS话题格式相互转换"></a>4.2.9.1 OpenCV中图像格式和ROS话题格式相互转换</h5><p><strong>机器人端</strong>启动摄像头roslaunch robot_vision robot_camera.launch</p><p><strong>PC****端</strong>启动rosrun robot_vision cv_bridge_test.py</p><p><strong>PC****端</strong>用两个终端打开两个rqt_image_view工具，分别订阅&#x2F;image_raw&#x2F;compressed和&#x2F;cv_bridge_image</p>]]></content>
      
      
      <categories>
          
          <category> 毕设学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Learning Notes(2)</title>
      <link href="/2024/02/16/linux-learning-notes(2)/"/>
      <url>/2024/02/16/linux-learning-notes(2)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>事情的起因是我按照教程运行搭载在JetsonNano上的ubuntu系统，发现系统无法连接wifi，于是查找资料试图解决。当我最后解决问题整理完这篇笔记之后我在脑海中构建了我的思考过程，发现解决这个问题其实也只需四到五步的推理，但是事实总是如此，为了这几步的解决步骤，我花了两个下午两个晚上，这么一想其实我的效率还可以更高点，下次我从早上开始学习思考，再遇到类似的未知领域的问题是不是一天就能想出来呢？我陷入了好奇之中。</p></blockquote><h3 id="1-网络拓扑结构的理解"><a href="#1-网络拓扑结构的理解" class="headerlink" title="1 网络拓扑结构的理解"></a>1 网络拓扑结构的理解</h3><h4 id="1-1-输入ifconfig，查看网络信息"><a href="#1-1-输入ifconfig，查看网络信息" class="headerlink" title="1.1 输入ifconfig，查看网络信息"></a>1.1 输入<code>ifconfig</code>，查看网络信息</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">eth0: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">416</span><span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu <span class="token number">1500</span>        inet <span class="token number">192.168</span>.0.16  netmask <span class="token number">255.255</span>.255.0  broadcast <span class="token number">192.168</span>.0.255        inet6 fe80::4320:3860:46:8803  prefixlen <span class="token number">64</span>  scopeid 0x2<span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>link<span class="token operator">></span>        ether <span class="token number">48</span>:b0:2d:5b:dc:56  txqueuelen <span class="token number">1000</span>  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets <span class="token number">18660</span>  bytes <span class="token number">1886816</span> <span class="token punctuation">(</span><span class="token number">1.8</span> MB<span class="token punctuation">)</span>        RX errors <span class="token number">0</span>  dropped <span class="token number">0</span>  overruns <span class="token number">0</span>  frame <span class="token number">0</span>        TX packets <span class="token number">20777</span>  bytes <span class="token number">6823167</span> <span class="token punctuation">(</span><span class="token number">6.8</span> MB<span class="token punctuation">)</span>        TX errors <span class="token number">0</span>  dropped <span class="token number">0</span> overruns <span class="token number">0</span>  carrier <span class="token number">0</span>  collisions <span class="token number">0</span>        device interrupt <span class="token number">150</span>  base 0xe000  lo: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">7</span><span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>UP,LOOPBACK,RUNNING<span class="token operator">></span>  mtu <span class="token number">65536</span>        inet <span class="token number">127.0</span>.0.1  netmask <span class="token number">255.0</span>.0.0        inet6 ::1  prefixlen <span class="token number">128</span>  scopeid 0x1<span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>host<span class="token operator">></span>        loop  txqueuelen <span class="token number">1</span>  <span class="token punctuation">(</span>Local Loopback<span class="token punctuation">)</span>        RX packets <span class="token number">2505</span>  bytes <span class="token number">180228</span> <span class="token punctuation">(</span><span class="token number">180.2</span> KB<span class="token punctuation">)</span>        RX errors <span class="token number">0</span>  dropped <span class="token number">0</span>  overruns <span class="token number">0</span>  frame <span class="token number">0</span>        TX packets <span class="token number">2505</span>  bytes <span class="token number">180228</span> <span class="token punctuation">(</span><span class="token number">180.2</span> KB<span class="token punctuation">)</span>        TX errors <span class="token number">0</span>  dropped <span class="token number">0</span> overruns <span class="token number">0</span>  carrier <span class="token number">0</span>  collisions <span class="token number">0</span>rndis0: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">409</span><span class="token operator"><span class="token file-descriptor important">9</span>&lt;</span>UP,BROADCAST,MULTICAST<span class="token operator">></span>  mtu <span class="token number">1500</span>        ether 6a:64:62:35:cd:69  txqueuelen <span class="token number">1000</span>  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets <span class="token number">0</span>  bytes <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0.0</span> B<span class="token punctuation">)</span>        RX errors <span class="token number">0</span>  dropped <span class="token number">0</span>  overruns <span class="token number">0</span>  frame <span class="token number">0</span>        TX packets <span class="token number">0</span>  bytes <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0.0</span> B<span class="token punctuation">)</span>        TX errors <span class="token number">0</span>  dropped <span class="token number">0</span> overruns <span class="token number">0</span>  carrier <span class="token number">0</span>  collisions <span class="token number">0</span>usb0: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">409</span><span class="token operator"><span class="token file-descriptor important">9</span>&lt;</span>UP,BROADCAST,MULTICAST<span class="token operator">></span>  mtu <span class="token number">1500</span>        ether 6a:64:62:35:cd:6b  txqueuelen <span class="token number">1000</span>  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets <span class="token number">0</span>  bytes <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0.0</span> B<span class="token punctuation">)</span>        RX errors <span class="token number">0</span>  dropped <span class="token number">0</span>  overruns <span class="token number">0</span>  frame <span class="token number">0</span>        TX packets <span class="token number">0</span>  bytes <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0.0</span> B<span class="token punctuation">)</span>        TX errors <span class="token number">0</span>  dropped <span class="token number">0</span> overruns <span class="token number">0</span>  carrier <span class="token number">0</span>  collisions <span class="token number">0</span>wlan0: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">416</span><span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu <span class="token number">1500</span>        inet <span class="token number">192.168</span>.9.1  netmask <span class="token number">255.255</span>.255.0  broadcast <span class="token number">192.168</span>.9.255        inet6 fe80::1acc:18ff:fe9b:24a4  prefixlen <span class="token number">64</span>  scopeid 0x2<span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>link<span class="token operator">></span>        ether <span class="token number">18</span>:cc:18:9b:24:a4  txqueuelen <span class="token number">1000</span>  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets <span class="token number">0</span>  bytes <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0.0</span> B<span class="token punctuation">)</span>        RX errors <span class="token number">0</span>  dropped <span class="token number">1</span>  overruns <span class="token number">0</span>  frame <span class="token number">0</span>        TX packets <span class="token number">315</span>  bytes <span class="token number">74205</span> <span class="token punctuation">(</span><span class="token number">74.2</span> KB<span class="token punctuation">)</span>        TX errors <span class="token number">0</span>  dropped <span class="token number">0</span> overruns <span class="token number">0</span>  carrier <span class="token number">0</span>  collisions <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-理解命令行的基本内容"><a href="#1-2-理解命令行的基本内容" class="headerlink" title="1.2 理解命令行的基本内容"></a>1.2 理解命令行的基本内容</h4><ol><li><p><code>lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</code></p><ul><li><p><code>lo</code>：网卡名称为 lo，代表本地回环接口。</p></li><li><p><code>flags=73&lt;UP,LOOPBACK,RUNNING&gt;</code>：表示该接口卡的状态标志，其中：</p><ul><li><code>UP</code>：接口卡已启用。</li><li><code>LOOPBACK</code>：接口卡为本地回环接口。</li><li><code>RUNNING</code>：接口卡正在运行。</li></ul></li><li><p><code>mtu 65536</code>：接口卡的最大传输单元 (MTU) 大小为 65536 字节。</p></li></ul></li><li><p><code>inet 127.0.0.1  netmask 255.0.0.0</code></p><ul><li><code>inet 127.0.0.1</code>：接口卡的 IPv4 地址为 127.0.0.1，它是本地回环地址，用于在本机内部进行通信。</li><li><code>netmask 255.0.0.0</code>：子网掩码为 255.0.0.0，表示回环地址的范围。</li></ul></li><li><p><code>inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</code></p><ul><li><code>inet6 ::1</code>：接口卡的 IPv6 地址为 ::1，它是本地回环地址的 IPv6 版本。</li><li><code>prefixlen 128</code>：IPv6 地址的前缀长度为 128。</li><li><code>scopeid 0x10&lt;host&gt;</code>：接口卡的作用域 ID，表示本地主机。</li></ul></li><li><p><code>loop  txqueuelen 1  (Local Loopback)</code></p><ul><li><code>loop</code>：接口类型为回环接口。</li><li><code>txqueuelen 1</code>：发送队列长度为 1。</li><li><code>(Local Loopback)</code>：本地回环接口。</li></ul></li><li><p><code>RX packets 2505  bytes 180228 (180.2 KB)</code></p><ul><li><code>RX packets 2505</code>：接收数据包的数量为 2505。</li><li><code>bytes 180228</code>：接收数据的字节数为 180228 字节（180.2 KB）。</li></ul></li><li><p><code>RX errors 0  dropped 0  overruns 0  frame 0</code></p><ul><li><code>RX errors 0</code>：接收错误的数量为 0。</li><li><code>dropped 0</code>：丢弃的接收数据包数量为 0。</li><li><code>overruns 0</code>：接收数据超出缓冲区的次数为 0。</li><li><code>frame 0</code>：帧错误的数量为 0。</li></ul></li><li><p><code>TX packets 2505  bytes 180228 (180.2 KB)</code></p><ul><li><code>TX packets 2505</code>：发送数据包的数量为 2505。</li><li><code>bytes 180228</code>：发送数据的字节数为 180228 字节（180.2 KB）。</li></ul></li><li><p><code>TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></p><ul><li><code>TX errors 0</code>：发送错误的数量为 0。</li><li><code>dropped 0</code>：丢弃的发送数据包数量为 0。</li><li><code>overruns 0</code>：发送数据超出缓冲区的次数为 0。</li><li><code>carrier 0</code>：载波错误的数量为 0。</li><li><code>collisions 0</code>：碰撞的数量为 0。</li></ul></li></ol><h3 id="2-检测是否有WIFI网络"><a href="#2-检测是否有WIFI网络" class="headerlink" title="2 检测是否有WIFI网络"></a>2 检测是否有WIFI网络</h3><p>输入<code>sudo nmcli devide wifi list</code>，检测是否有wifi信号，若无，优先检测硬件情况，查看网卡的插拔情况是否正常，若正常，排除硬件问题，进行下一步。</p><h3 id="3-排查软件方面的网络配置情况"><a href="#3-排查软件方面的网络配置情况" class="headerlink" title="3 排查软件方面的网络配置情况"></a>3 排查软件方面的网络配置情况</h3><ol><li><p><strong>检查无线适配器状态:</strong> 确保无线适配器已启用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> nmcli radio wifi on<span class="token comment">#sudo nmcli radio wifi off #关闭无线网络</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>刷新Network Manager:</strong> 刷新Network Manager以确保其了解当前网络状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">service</span> network-manager restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>验证无线配置:</strong> 仔细检查<code>wlan0</code>的无线配置。确保无线接口使用以下命令正确配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> nmcli dev show wlan0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>扫描Wi-Fi网络:</strong> 手动触发Wi-Fi扫描</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> nmcli device wifi rescan<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>检查Wi-Fi网络列表:</strong> 扫描后，使用以下命令检查可用的Wi-Fi网络：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> nmcli device wifi list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>查看Network Manager日志:</strong> 检查Network Manager日志是否有错误或相关信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">journalctl <span class="token parameter variable">-xe</span> <span class="token operator">|</span> <span class="token function">grep</span> NetworkManager<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>更新Network Manager:</strong> 确保您的Network Manager 已更新至最新版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>检查驱动程序问题:</strong> 验证无线适配器的驱动程序是否已安装并正常工作。</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> lshw <span class="token parameter variable">-C</span> network<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>一般来说假如前三步都没问题，第四步手动扫描wifi时出现报错，例<code>Error: Scanning not allowed while unavailable or activating.</code>这个错误表明在无线网络设备不可用或正在激活时，无法执行扫描操作。则缩小范围，检测设备是否正常启动。</p><h3 id="4-查看系统中的各种网络设备及其状态"><a href="#4-查看系统中的各种网络设备及其状态" class="headerlink" title="4 查看系统中的各种网络设备及其状态"></a>4 查看系统中的各种网络设备及其状态</h3><h4 id="4-1-输入nmcli-device，确保无线网络设备处于可用状态。"><a href="#4-1-输入nmcli-device，确保无线网络设备处于可用状态。" class="headerlink" title="4.1 输入nmcli device，确保无线网络设备处于可用状态。"></a>4.1 输入<code>nmcli device</code>，确保无线网络设备处于可用状态。</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">eth0    ethernet  connected  Wired connection <span class="token number">1</span>  <span class="token comment">#以太网设备，已连接，使用有线连接1。</span>l4tbr0  bridge    unmanaged  --  <span class="token comment">#桥接设备，未受 NetworkManager 管理。   </span>dummy0  dummy     unmanaged  --  <span class="token comment">#虚拟设备，未受 NetworkManager 管理。  </span>rndis0  ethernet  unmanaged  --  <span class="token comment">#以太网设备，未受 NetworkManager 管理。  </span>usb0    ethernet  unmanaged  --  <span class="token comment">#以太网设备，未受 NetworkManager 管理。  </span>lo      loopback  unmanaged  --  <span class="token comment">#回环设备（loopback），未受 NetworkManager 管理。</span>wlan0   wifi      unmanaged  --  <span class="token comment">#无线设备，未受 NetworkManager 管理。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据这些信息，<code>wlan0</code> 设备当前处于未受 NetworkManager 管理的状态，可能是由于之前在配置文件中指定了 <code>unmanaged-devices=interface-name:wlan0</code>。</p><h4 id="4-2-配置文件将-wlan0-设备纳入-NetworkManager-的管理"><a href="#4-2-配置文件将-wlan0-设备纳入-NetworkManager-的管理" class="headerlink" title="4.2 配置文件将 wlan0 设备纳入 NetworkManager 的管理"></a>4.2 配置文件将 <code>wlan0</code> 设备纳入 NetworkManager 的管理</h4><p>配置文件并删除或注释掉相关配置行以将 <code>wlan0</code> 设备纳入 NetworkManager 的管理，可以按照以下步骤进行操作：</p><ol><li><p>打开终端，并使用合适的文本编辑器（如 nano、vim 等）以管理员权限打开 NetworkManager 主配置文件。在大多数 Linux 发行版上，该文件位于 <code>/etc/NetworkManager/NetworkManager.conf</code>。</p><p>例如，在终端中输入以下命令打开文件：</p><pre class="line-numbers language-none"><code class="language-none">sudo vim &#x2F;etc&#x2F;NetworkManager&#x2F;NetworkManager.conf <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将managed&#x3D;false<br>改成managed&#x3D;true</p></li><li><p>在文本编辑器中，查找包含 <code>unmanaged-devices</code> 的行。该行可能类似于 <code>unmanaged-devices=interface-name:wlan0</code>。请注意，可能还有其他设备也被列为未受管理。</p></li><li><p>要删除这一行配置，请将其完全从文件中删除。要注释掉这一行，可以在行的开头添加一个井号 <code>#</code>。</p><p>示例：</p><pre class="line-numbers language-none"><code class="language-none"># unmanaged-devices&#x3D;interface-name:wlan0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>保存更改（在 nano 编辑器中按下 <code>Ctrl + O</code>，然后按下 <code>Enter</code>），然后关闭编辑器（在 nano 编辑器中按下 <code>Ctrl + X</code>）。</p></li><li><p>重新启动 NetworkManager 服务，以使更改生效。可以使用以下命令：</p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl restart NetworkManager<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>显示当前系统中的网络连接配置信息，查看已连接的网络</p> <pre class="line-numbers language-none"><code class="language-none">nmcli connection show <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="5-解决系统每次重启都会重置配置文件"><a href="#5-解决系统每次重启都会重置配置文件" class="headerlink" title="5 解决系统每次重启都会重置配置文件"></a>5 解决系统每次重启都会重置配置文件</h3><p>系统在重启后自动生成了 <code>unmanaged-devices=interface-name:wlan0</code> 这段语句，可能是因为 NetworkManager 在重启时读取了默认的配置文件，并将之前的更改覆盖掉了。</p><p>为了解决这个问题，你可以尝试以下方法：</p><ol><li><p>创建一个 NetworkManager 配置文件片段：创建一个新的配置文件片段，其中包含你希望保留的配置项。在这个片段中，删除或注释掉 <code>unmanaged-devices=interface-name:wlan0</code> 这一行。例如，你可以创建一个名为 <code>/etc/NetworkManager/conf.d/99-custom.conf</code> 的文件。</p><p>使用以下命令创建并编辑配置文件片段：</p><pre class="line-numbers language-none"><code class="language-none">复制代码sudo nano &#x2F;etc&#x2F;NetworkManager&#x2F;conf.d&#x2F;99-custom.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在编辑器中添加以下内容：</p><pre class="line-numbers language-none"><code class="language-none">复制代码[keyfile]unmanaged-devices&#x3D;none<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>保存更改（在 nano 编辑器中按下 <code>Ctrl + O</code>，然后按下 <code>Enter</code>），然后关闭编辑器（在 nano 编辑器中按下 <code>Ctrl + X</code>）。</p></li><li><p>重新启动 NetworkManager 服务：</p><pre class="line-numbers language-none"><code class="language-none">复制代码sudo systemctl restart NetworkManager<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>这样，当 NetworkManager 重启时，它将读取新的配置文件片段，并应该不再生成 <code>unmanaged-devices=interface-name:wlan0</code> 这段语句。</p><p>注意：确保新创建的配置文件片段位于 <code>/etc/NetworkManager/conf.d/</code> 目录中，这样 NetworkManager 在读取配置时会包含这个目录下的所有配置文件。</p>]]></content>
      
      
      <categories>
          
          <category> 毕设学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Learning Notes(1)</title>
      <link href="/2024/02/06/linux-learning-notes(1)/"/>
      <url>/2024/02/06/linux-learning-notes(1)/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token parameter variable">-l</span><span class="token function">ls</span> <span class="token parameter variable">-a</span><span class="token function">touch</span><span class="token function">mkdir</span><span class="token builtin class-name">pwd</span> 看目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>rm -r删除文件夹以及子目录下的所有文件</p><p>rmdir只能删除空文件夹</p><h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><p>cp bingda1.txt bingda2.txt</p><h3 id="拷贝文件夹"><a href="#拷贝文件夹" class="headerlink" title="拷贝文件夹"></a>拷贝文件夹</h3><p>cp -r bingda1 bingda3</p><p>移动(可以重命名文件和文件夹)</p><p>mv bingda3.txt bingda1.txt(起到重命名的作用)</p><h3 id="下载删除软件"><a href="#下载删除软件" class="headerlink" title="下载删除软件"></a>下载删除软件</h3><p>sudo apt update</p><p>sudo apt install tree</p><p>sudo apt rm tree</p><p>apt list –installed 查看已下载的安装包</p><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>i,a,o进入编辑模式，esc退出</p><p>:wq 保存</p><p>:q!强制退出</p><p>dd删除当前行</p><p>G快速移动到最后一行</p><h4 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h4><p>home  end</p><p>cat 系统查看</p><h3 id="文件权限修改"><a href="#文件权限修改" class="headerlink" title="文件权限修改"></a>文件权限修改</h3><p>chmod 用于修改、设置文件权限。chmod 修改文件权限主要有两种方式：字母法与数字法。 字母法：我们知道文件权限是由字母 r,w,x 来表示的，字母法修改权限的方式为 chmod (u g o a) (+ - &#x3D;) (r w x) (文件名)； u 代表用户，g 代表用户组，o 代表其他用户，a 代表三者全部。 +代表增加权限，-代表撤销权限，&#x3D;代表设置权限</p><p>那么把用户，用户组，其他用户权限全部设置为可读可写可执行可以是： chmod 777 bingda.txt 或者 chmod +133 bingda.tx</p><h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>su进入root用户</p><h3 id="cd进入目录"><a href="#cd进入目录" class="headerlink" title="cd进入目录"></a>cd进入目录</h3><p>cd ..                  返回上一级目录</p><p>cd ..&#x2F;..               返回上两级目录</p><p>cd或cd ~           返回home目录</p><p>cd &#x2F;                   返回根目录</p><p>cd -                   返回刚才的目录</p><p>cd - 目录名       返回指定目录</p>]]></content>
      
      
      <categories>
          
          <category> 毕设学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/02/05/hello-world/"/>
      <url>/2024/02/05/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="The-idea-was-initially-conceived"><a href="#The-idea-was-initially-conceived" class="headerlink" title="The idea was initially conceived."></a>The idea was initially conceived.</h3><blockquote><p>事情起源于一个小小的念头。但这并不是一时念起。起初是因为遗憾吧，我的收藏夹里收藏了很多技术，但是我一直都只是在外面观望驻足，备考研究生考试的这一年，我几乎忘记了所有的编程技巧，我对技术的热爱因为现实的自欺而一直停留在过去，直到现在我才敢说我以及走出来了，形而上学上的自我纠结让我好一段时间开始反思自己，这个问题对内上，它解释为自我的发展上限和在社会竞争关系上的意识对待问题，对内上则表现为存在主义上的迷茫，所幸书籍给了我答案，我就像加缪书里的西西弗，想通之前我推石上山，想通之后我还是推石，只不过上不上山无所谓了。</p></blockquote><p>个人博客的第一次搭建是我大一时候的事情了，那个时候我匆匆交了一份问卷上去，现在我终于能好好地再把这张试卷再做一篇。借此顺便记录一下我这几天的学习笔记吧。</p><h3 id="1-安装Nodejs-git，搭建github仓库"><a href="#1-安装Nodejs-git，搭建github仓库" class="headerlink" title="1 安装Nodejs&#x2F;git，搭建github仓库"></a>1 安装Nodejs&#x2F;git，搭建github仓库</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">node</span> <span class="token parameter variable">-v</span><span class="token comment">#查看node版本</span><span class="token function">npm</span> <span class="token parameter variable">-v</span><span class="token comment">#查看npm版本</span><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> cnpm <span class="token parameter variable">--registry</span><span class="token operator">=</span>http://registry.npm.taobao.org<span class="token comment">#安装淘宝的cnpm 管理器</span>cnpm <span class="token parameter variable">-v</span><span class="token comment">#查看cnpm版本</span>cnpm <span class="token function">install</span> <span class="token parameter variable">-g</span> hexo-cli    <span class="token comment">#安装hexo框架</span>hexo <span class="token parameter variable">-v</span><span class="token comment">#查看hexo版本</span><span class="token function">mkdir</span> blog<span class="token comment">#创建blog目录</span><span class="token builtin class-name">cd</span> blog <span class="token comment">#进入blog目录</span><span class="token function">sudo</span> hexo init <span class="token comment">#生成博客 初始化博客</span>hexo s<span class="token comment">#启动本地博客服务</span>http://localhost:4000/<span class="token comment">#本地访问地址</span>hexo n <span class="token string">"我的第一篇文章"</span> <span class="token comment">#创建新的文章 </span><span class="token comment">#Github创建一个新的仓库 YourGithubName.github.io</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-检测4000端口是否被占用"><a href="#2-检测4000端口是否被占用" class="headerlink" title="2 检测4000端口是否被占用"></a>2 检测4000端口是否被占用</h3><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">netstat -ano #列出所有端口的使用情况 #列出计算机上所有端口的使用情况，包括TCP和UDP端口，以及这些端口对应的进程ID（PID）。-a 参数表示显示所有连接和侦听端口，-n 参数表示以数字形式显示地址和端口号，-o 参数显示拥有的进程ID。netstat -aon|findstr &quot;4000&quot; #查看被占用端口对应的 PIDtasklist|findstr &quot;30806&quot; #查看指定 PID 的进程taskkill &#x2F;T &#x2F;F &#x2F;PID 30806  #结束进程#强制（&#x2F;F参数）杀死 pid 为 9088 的所有进程包括子进程（&#x2F;T参数）   #之后我们就可以结束掉这个进程，这样我们就可以释放该端口来使用了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-配置-config-yml"><a href="#3-配置-config-yml" class="headerlink" title="3 配置_config.yml"></a>3 配置_config.yml</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># Deployment</span><span class="token comment">## Docs: https://hexo.io/docs/one-command-deployment</span><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">'git'</span>   <span class="token key atrule">repo</span><span class="token punctuation">:</span> <span class="token string">'https://github.com/Answerfour/Answerfour.github.io.git'</span> <span class="token comment">#个人仓库名</span>  <span class="token key atrule">branch</span><span class="token punctuation">:</span> <span class="token string">'master'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-部署仓库"><a href="#4-部署仓库" class="headerlink" title="4 部署仓库"></a>4 部署仓库</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cnpm <span class="token function">install</span> <span class="token parameter variable">--save</span> hexo-deployer-git <span class="token comment">#在blog目录下安装git部署插件</span>hexo d<span class="token comment">#部署到Github仓库里</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5-修改主题"><a href="#5-修改主题" class="headerlink" title="5 修改主题"></a>5 修改主题</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/litten/hexo-theme-yilia.git themes/yilia  <span class="token comment">#下载yilia主题到本地</span><span class="token comment">#修改hexo根目录下的 _config.yml 文件 ： theme: yilia</span>hexo c<span class="token comment">#清理一下</span>hexo g<span class="token comment">#生成</span>hexo d<span class="token comment">#部署到远程Github仓库</span>https://YourGithubName.github.io/  <span class="token comment">#查看博客</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
